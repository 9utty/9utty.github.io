---
title: "[OS] 프로세스의 개념"
date: 2021-02-01 10:13:00 +0800
categories: [Computer Science, Operating System]
tags: [그림으로 배우는 구조와 원리 운영체제, chapter 03 프로세스와 스레드, 프로세스 생명주기, 프로세스, 프로세스 개념, 프로세스 구조, 프로세스 메모리 구조, 프로세스 상태] 
---



# 01 프로세스의 개념과 상태 변화

본 설명은 책 "그림으로 배우는 구조와 원리 운영체제 개정 3판"를 읽으며 제 나름대로 해석하고 정리해 보았습니다.😉

# 1. 프로세스의 개념

먼저, 프로세스의 개념을 알기 전에 프로세스의 개념이 언제부터 등장했는지 살펴보자. 초기에 컴퓨터는 프로그램을 한번에 하나씩 실행했기 때문에 한 프로그램이 자원을 독점했었다. 그러다 다중 프로그래밍의 환경이 생기면서 여러 프로그램을 메모리에 적재하여 병행 실행할 수 있게 되었다. 때문에 프로그램들은 컴퓨터 자원을 공유하기에 이를 제어하는 방법이 필요했고, 이 과정에서 프로세스가 등장한 것이다.

프로세스의 개념을 먼저 간단히 설명하자면, 프로세스란

- 실행 중인 프로그램
- 비동기적 행위
- 실행 중인 프로시저
- 실행 중인 프로시저의 제어 추적
- 운영체제에 들어 있는 프로세스 제어 블록
- 프로세서에 할당하여 실행할 수 있는 개체 디스패치가 가능한 대상

이라고 정의할 수 있다. 

여기서 가장 와닿는 정의는 "실행 중인 프로그램" 일 것이다. 예를들면 우리가 웹 브라우저 창을 한 개 열면 프로세스 한 개를 생성하고, 2개를 열면 프로세스 2개를 생성하는 것이다. 이렇게 프로세스가 실행 중인 프로그램이 되려면 프로세서 점유 시간, 메모리, 파일, 입출력 장치 같은 자원이 필요하고 또 현재의 활동 상태를 나타내는 프로그램 카운터, 프로세서의 현재 활동(레지스터 내용)도 포함하고 있다.

다시 한번 말하지만, 프로세스는 **실행 중인 프로그램** 이다. 프로그램은 컴파일한 코드와 초기화 전역변수, 문자열과 문자열 상수 등 **정적 데이터를 포함하는 정적인 개체**이다. 그리고 이 프로그램이 실행이 되면 **프로세스**가 되는 것이고 프로세스는 아래의 그림과 같은 메모리 구조를 갖는다.

![프로세스 (1)](\assets\img\프로세스\프로세스 (1).png)

프로세스는 프로그램 카운터나 레지스터처럼 현재 어떤 자원을 사용하는지 관련 정보가 들어 있는 **동적인 개체**이다.

그럼 지금부터, 스택, 힙, 데이터, 코드 영역에 대해 조금 더 자세히 살펴보자.

### 스택

**스택은 데이터를 일시적으로 저장하는 영역이다.** 데이터를 *일시적*으로 저장한다는 것은 즉, 함수를 호출하게 되면 함수의 반환 주소, 반환 값, 매개변수 등에 이 영역을 활용하기 때문에 **함수를 호출할수록 커지고 반환하면 줄어드는 것이다.** 위의 그림에서 볼 수 있듯이 보통 힙과 인접한 방향으로 점점 커져 스택 포인터와 힙 포인터를 만나면 메모리가 소진되었다는 것을 의미한다.

### 힙

**힙은 코드 영역과는 별도로 유지되는 자유 영역이다.** 동적으로 메모리를 할당하려고 프로그램 실행 중 시스템 호출을 사용했다가 해제하는 방법으로 활용한다. 동적 메모리 할당이 발생하면 위로 커진다.

### 데이터

**데이터는 프로그램의 가상 주소 공간이다.** 전역변수나 정적변수를 저장하거나 할당하고 실행하기 전에 초기화한다.

### 코드

**코드는 실행 명령을 포함하는 메모리이거나 목적 파일이 있는 프로그램 영역이다.** 프로그램을 시작할 때 프로세서가 디스크에서 읽어 실행하는 프로그램을 저장한다.

프로그래밍 기초가 있는 사람은 아래의 C 코드와 함께 비교해서 본다면 더 빠르게 이해할 수 있을 것이다.

![프로세스 (4)](\assets\img\프로세스\프로세스 (4).png)

# 2. 프로세스의 상태 변화와 상태 정보

아까 프로세스의 상태란 용어가 잠깐 나왔었다. 프로세스의 상태 크게 실행 상태 비실행 상태로 구분되는데 운영체제가 당연히 이 상태에 따라 프로세스를 제어하고 점검한다. 그럼 지금부터 프로세스의 상태 변화에 대해 알아보자.

## 2.1 프로세스의 상태 변화

일단 큰 프름을 살펴보자.

운영체제가 프로세스를 생성하면 비실행 상태로 초기화해서 실행을 기다린다. 실행 중인 프로세스를 종료하거나 인터럽트가 발생하면 비실행 프로세스 중인 프로세스 하나를 선택해 실행 상태로 바꾼다. 이때 인터럽트된 프로세스는 비실행 상태가 된다. 그리고 실행 중인 프로세스는 새로운 자원을 할당받기 위해 프로세서를 기다리는 비실행 상태로 바뀌기도 한다.

![프로세스 (2)](\assets\img\프로세스\프로세스 (2).png)

이 과정을 더 세분화할 수 있다. 세분화하면 프로세스의 상태를 준비, 실행, 대기로 나눠진다. 프로세스는 시스템에서 준비, 실행, 대기 상태로 바뀌면서 실행하고 종료하고 시스템을 떠날 때까지 이 과정을 반복한다.

![프로세스 (3)](\assets\img\프로세스\프로세스 (3).png)

이를 프로세스의 생명주기라고 하는데 각각에 대해 설명하자면,

- New: 프로세스가 생성됨
- Running: 명령어가 실행된다. CPU에 명령어를 로드해서 실행하는 상태.
- Waiting : 프로세스가 어떤 이벤트가 일어나기를 기다리는 상태 ( ex. I/O completion) 다른 프로세스를 기다리는 상태.
- Ready : 프로세스가 프로세서에게 할당되기를 기다리는 상태
- Terminated: 프로세스가 실행을 끝난 상태 (ex. exit() )

여기서 waiting 대기 상태에 조금 더 설명하자면, 대기상태에서는 이벤트 처리 혹은 I/O를 기다리기 때문에 CPU를 할당받아도 실행이 되지 않는다. (BLOCK 상태)

그럼 각각의 상태가 무엇인지 알았으니 상태가 변화하는 과정을 살펴보자.

- 준비 → 실행 : 준비 큐(ready queue) 맨 앞에 있던 프로세스가 프로세서를 점유하는 것을 **디스패치**라고 한다. 다중 프로그래밍 운영체제에서는 실행 상태인 프로세스가 할당된 시간만큼 프로세서를 사용하도록 하여 특정 프로세스가 프로세서를 계속 독점하는 것을 방지한다.
- 실행 → 준비 : 운영체제는 특정 프로세스가 프로세서를 독점하지 않도록 인터럽트 클록을 두어 할당된 시간 동안만 프로세서를 점유하게 한다. 따라서 프로세스가 일정시간이 되어도(timeout) 프로세서를 반환하지 않으면 클록이 인터럽트를 발생시켜 운영체제가 프로세서의 제어권을 가져간다.
- 실행 → 대기(보류) : 할당된 시간 이전에 프로세스에 입출력 연상 이나 새로운 자원 요청 등의 문제로 프로세서를 스스로 양도하면 대기 상태가 된다.
- 대기 → 준비 : 프로세스는 입출력 작업이 끝나면 wake up 으로 대기에서 준비 상태가 된다.

즉, 이 중 프로세스가 스스로 하는 것은 **대기** 뿐이고 나머지는 외부 조건으로 발생한다.