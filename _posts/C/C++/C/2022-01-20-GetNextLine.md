---
title: "C언어로 문자열파싱하는 라이브러리만들기"

categories:
  - C
tags:
  - [Parsing, C, read]

toc: true
toc_sticky: true
---

# C언어로 문자열파싱하는 라이브러리만들기

문자열을 받아 "\n" 문자열이 나오기전까지의 한 줄을 파싱하는 라이브러리를 만들어보자.

### 표준스트림

0 : 표준 입력

1 : 표준 출력

2 : 표준 에러

### OPEN_MAX 확인하는 법

```C
/* 터미널에서 확인방법 */
getconf OPEN_MAX
/* 클러스터 맥에서는 256 */
```

### fd (파일디스크립터)

- open함수에서 사용을 하게 되는데 open에서 fd는 4번부터 번호를 가지게 되는데, 번호에 지정된 것은 읽을 파일 번호를 뜻하게 된다.

### read

sszie_t read(int fd, void\* buff, size_t bytes)

- fd는 위에 설명을 했던거고
- 반환값에 대해서 이야기를 해보자
  - 반환값은 읽어온 byte 수를 반환하게 되는데, 그 값이 만약에 -1 이라면 오류가 나오는 경우이다.
  - 0이 반환된다면 end of file을 뜻하게 된다.

# get_next_line.c

## get_next_line(int fd)

- **static char 로 사용하는 이유**

  - **메모리 영역은 크게 4가지로 나눌 수 있다.**

    - **첫 번째, 스택 메모리 섹터**
      - 우리가 함수를 호출하고 우리가 변수를 만들고 함수 안에서 배열 등을 선언했을때 자리를 잡는 메모리이다. 특징으로는 순차적으로 주소를 가지게 된다. 보통의 컴퓨터는 큰주소부터 작은주소로 움직인다.
      - 함수가 끝날때마다 리턴하는 값을 복사하고, 그 함수가 차지하고 있던 메모리는 없어진다.
    - **두 번째, 힙 메모리 섹터**
      - 우리가 동적할당을 하게 됬을때 이 힙 메모리에 저장하게 된다. 여기서에서는 동적할당을 할때마다 순차적인 주소를 가지는 것보다는 여기저기 주소를 가지게 된다.
    - **세 번째, 데이터 메모리 섹터**
      - 데이터 메모리 섹터는 실행중에 움직이는 메모리가 아니다.
      - 우리가 전역변수, static(정적) 변수를 선언하게 되면 이 곳 데이터 메모리에 저장되게 된다.
      - 이 데이터 메모리는 프로그램이 끝날때까지 없어지지 않고 계속 그 자리에 있게 된다.
    - **네 번째, 코드 메모리 섹터**
      - 코드 메모리 섹터는 우리가 컴파일할때 필요한 코드들 그러니까 우리가 작성한 코드들이 들어있는 메모리라고 보면 된다.

  - 우리가 static을 사용하는 이유는 위에서 설명했듯이, 데이터 메모리 섹터는 프로그램이 종료가 될때까지 계속 그 값을 가지고 있게 된다. 그래서 static char \*temp; 이렇게 선언을 했을때 그 포인터는 주소값을 계속 가지고 있게 된다. 이건 함수가 종료되도 똑같다. 프로그램이 종료가 되야 없어진다. 그렇기 때문에 언제 어디서든 접근을 할 수 있어야 하기 때문에 static으로 선언하는 이유이다.
  - static으로 선언시에 초기화를 하지 않으면 자동으로 NULL로 초기화가 된다.

- **temp = ft_get_read(temp, fd)**

  ![get_read.png](https://user-images.githubusercontent.com/86397600/231408080-f8742693-c4f7-47dd-a03a-1d3ef66b90a4.png)

  - ft_get_read 함수의 리턴값은 위에 그림에 나타나 있는 temp의 주소를 반환하게 된다.

- **buff = ft_get_rework(temp)**

  ![get_rework.png](https://user-images.githubusercontent.com/86397600/231408080-f8742693-c4f7-47dd-a03a-1d3ef66b90a4.png)

  - buff는 결론적으로는 “42seoul\n\0”의 문자열을 가지고 있는 상태가 된다.

- **temp = ft_get_rest(temp)**

  ![get_rest.png](https://user-images.githubusercontent.com/86397600/231408444-15b896dd-1950-434f-bb69-c62daee2157c.png)

  - 함수내에서 *ptr은 substr함수로 새로운 주소를 받게 되고, 인자로 받은 *str(get_next_line에 선언된 static char *temp)를 free를 하고 그 *temp가 가리킬 수 있게 ft_get_rest가 새로운 주소를 반환하게 된다.

- 반환값
  - 반환값은 우리가 저장한 buff가 가지고 있는 주소를 넘기게 된다.

## bonus

### 기본 서브젝트와 보너스는 많이 다르지 않다.

- **차이라면 static char \*temp[256] 일 것이다**
  - **일단 256인 이유**
    - 우리가 사용하는 클러스터 맥에서 getconf OPEN_MAX 를 쳐보고 나오는 값이 256이였다. 그래서 256으로 했다
    - OPEN_MAX 는?
      - OPEN_MAX는 사실상 현재 리눅스 시스템에선 사용하는 건 아니다. 하지만 우리가 OPEN_MAX를 확인해야 하는 이유는 fd(파일디스크렙터)의 최댓값이 OPEN_MAX와 같기 때문이다.
      - 확인은 limits.h 라는 헤더파일에서 정의가 되어 있는걸 확인 할 수 있다. 이 정의된 값은 플렛폼들다마 다르다고 볼 수 있다.
  - **포인터 배열로 선언한 이유**
    - 포인터 배열로 선언하게 되면 좋은게 무엇일까요?
      - 포인터? 배열?
        - 포인터의 장점이 무엇일까요? 메모리 크기와 상관없이 그 첫 시작 주소를 가질 수 있기 때문이다.
      - 여러 파일들의 내용을 각각 적어서 저장하고, 그 주소를 각각 포인터배열의 요소 하나하나에 넣을 수 있기 때문이다.
