---
title: "[Programming] 코테용 C++ 기본 문법 2"
date: 2021-11-22 17:32:30 +0800
categories: [Programming Language, C++]
tags: [c++]  
---

# C++

#include

- 전처리 지시자
- 함수의 원형을 미리 정의해야 함.

';'

- 종결자
- Enter, tab 을 넣더라도 결국 종결자를 통해 코드 정리됨.

main

- c++ 코드에서는 반드시 main의 이름을 가지고 있는 함수가 있어야 한다.

<<

- 데이터 흐름, 방향을 의미한다.

using namespace std

- std::cout 이 원래 형태
- 생략하기 위해 사용

주석

- /* 
- //

변수 선언

- 변수의 자료형
- 변수의 이름
  - 숫자로 시작할 수 없음
  - c++에서 사용하고 있는 키워드 사용할 수 없음
  - white space를 사용할 수 없음.
- 변수가 어디에 저장되는가(메모리 영역)

자료형

- short
- int
- long
- long long
- char '' (작은 따옴표만 사용가능)
  - chat b[] = { 'a', 'b', 'c', '\0'};
  - "" 명시적으로 null 문자가 포함 -> string

- const : 상수

  - #define PIE 3.141592
  - const float PIE = 3.1415926535;

- 데이터형 변환

  - 특정 데이터형의 변수에 다른 데이터형의 값을 대입했을 때

    ```c++
    char ch = 'M';
    cout << (int)ch << " " << endl;
    // 77 아스키코드
    static_cast<int>
    ```

    

  - 수식에 데이터형을 혼합하여 사용했을 때

  - 함수에 매개변수를 전달할때

auto

- 변수를 선언하고 값을 넣는 것이 아닌 선언할때 값을 대입하는 것
- c++ 자동으로 데이터형을 할당해준다.

배열(array) 

- 같은 데이터형의 집합
- typeName arrayName[arraySize];
- short month[12]; //선언

- short month[12] = { 1, 2, 3 };
- cout << month[0] << endl;
- 배열 원소에 대입할 값들을 콤마로 구분하여 중괄호로 묶어 선언한다.
- 초기화를 선언 이후 나중에 할 수 없음.
- 배열을 다른 배열에 통째로 대입할 수 없다.
- 초기화 값의 개수를 배열 원소의 개수보다 모자라게 제공할 수 있다.
- 배열을 부분적으로 초기화하면, 나머지 원소들은 모두 0으로 설정한다.
- 즉, 명시적으로 첫번째 원소만 0으로 초기화하면, 나머지 원소들은 모두 0으로 초기화된다.
- 배열을 초기화할때 대괄호 속을 비워두면 컴파일러가 초기화 값의 개수를 헤아려 배열 원소 개수를 저장한다.

문자열

- char a[] = "hello"
- [] 크기지정 X
- 쌍따옴표

- 문자열 길이 strlen

구조체

- 다른 데이터형이 허용되는 데이터의 집합

- struct MyStruct 
  {

  ​	string name;

  ​	string position;

  ​    float height;

  };

포인터

- C++: 객체지향 프로그래밍
  - 컴파일 시간이 아닌 실행 시간에 어떠한 결정을 내릴 수 있다.
    - 배열 생성
    - 재래적 절차적 프로그래밍 : 배열의 크기가 미리 결정됨
    - 객체지향 프로그래밍 : 배열의 크기를 실행 시간에 결정
- 사용할 주소에 이름을 붙인다.
- 포인터는 포인터의 이름이 주소를 나타낸다.
- 간접값, 연산자, 간접 참조 연산자 *
- new 연산자
  
  - 어떤 데이터형을 원하는지 new 연산자에게 알려주면, new 연산자는 그에 알맞은 크기의 메모리 블록을 찾아내고 그 블록의 주소를 리턴한다.
- delete 연산자
  - 사용한 메모리를 다시 메모리 폴로 환수
  - 환수된 메모리는 프로그램의 다른 부분이 다시 사용
  - new로 대입하지 않은 메모리는 delete로 해재할 수 없다.
  - 같은 메모리 블록을 연달아 두 번 delete로 해제할 수 없다.
  - new[]로 메모리를 대입할 경우 delete[]로 해제한다.
  - 대괄호를 사용하지 않았다면, delete도 대괄호를 사용하지 않아야 한다.

- loop

  ```c++
  for (int i = 0; i < 2; i++ ){
         cout << i;
      }
  ```

  
