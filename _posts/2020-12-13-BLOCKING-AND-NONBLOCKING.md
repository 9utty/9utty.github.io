---
title: "[Network] 실생활 예로 이해하는 Blocking Non-Blocking IO"
date: 2020-12-13 10:10:13 +0800
categories: [Computer Science, Network]
tags: [blocking]  

---

 # Blocking I/O & Non-Blocking I/O

![blocking_nonblocking (8)](\assets\img\blocking_nonblocking (8).png)

I/O 란?

입출력 장치로 부터 어떤 데이터를 주거나 보내는 역할.

![blocking_nonblocking (1)](\assets\img\blocking_nonblocking (1).png)

동기 & 비동기 : 흐름의 관점 

블러킹 & 넌 블러킹: 제어권의 관점 

# Blocking / Non-blocking

![blocking_nonblocking (2)](\assets\img\blocking_nonblocking (2).png)

행위자가 취한 행위 자체가, 또는 그 행위로 인해 다른 무엇이 **막혀버린, 제한된, 대기하는** 상태. 대개의 경우에는 나 이외의 대상으로 하여금 내가 Block 당하겠지만(Blocked), 어찌 되었든 문자 자체로는 나라는 **단일 개체 스스로의 상태** 를 나타냅니다.

- `호출된 함수` 가 자신이 할일을 모두 마칠 때 까지 제어권을 계속 가지고서 `호출한 함수` 에게 바로 돌려주지 않으면 Block

- `호출된 함수` 가 자신이 할일을 마치지 않더라도 바로 제어권을 건네주어(return) `호출한 함수` 가 다른 일을 진행할 수 있도록 해주면 Non Block

  → 제어권 : 행동할 수 있는 권리

```python
def 호출자() {
 functionA()
 functionB()
 functionC()
}

def functionA() {
/*
	 엄청난 로직
*/
return something
}
```

# Synchronous / Asynchronous

![blocking_nonblocking (3)](\assets\img\blocking_nonblocking (3).png)

**동시에 발생하는** 것들. 동시라는 것은 즉, 시라는 단일계 에서 **같이,함께** 무언가가 이루어지는 두 개 이상의 개체 혹은 이벤트를 의미한다.

- `호출된 함수`의 수행 결과 및 종료를 `호출한 함수`가 (`호출된 함수` 뿐 아니라 `호출한 함수` 도 함께) 신경쓰면 Synchronous
- `호출된 함수` 의 수행 결과 및 종료를 `호출된 함수` 혼자 직접 신경 쓰고 처리한다면 Asynchronous

# 실생활 예제로 이해해보자!

### 등장인물

- 개발팀장: 개발팀 작업 흐름을 조율하고, 사원들에게 업무를 지시함
- 사원1, 사원2, 사원3 : 개발팀장이 지시한 일을 성실하게 수행한다.

# 비동기 + 논블로킹

![blocking_nonblocking (4)](\assets\img\blocking_nonblocking (4).png)

- 시스템콜이 즉시 IO개시 여부를 반환한다. 사용자프로세스는 다른일을 할 수 있고(CPU는 다른 업무를 볼 수 있다), IO는 백그라운드에서 처리된다.
- IO 응답이 도착하면 신호나 콜백으로 IO전달을 완료한다.

1. 개발팀장이 사원1에게 업무 A를, 사원2에게 업무B를, 사원3에게 업무 C를 지시하였다. → 비동기
2. (그리고 바쁜 개발팀장은 개발팀 업무 말고 다른것도 업무 중..)
3. 사원들은 각자 본인의 맡은 작업을 끝내는대로 개발팀장에게 보고한다.(논블로킹)

→ 개발팀장이 업무들을 '비동기적' 으로 처리하고 사원들은 본인의 작업을 '논블로킹'방식으로 수행

# 동기 + 논블로킹

![blocking_nonblocking (5)](\assets\img\blocking_nonblocking (5).png)

- 동기블로킹의 개선안이지만 비효율적이다. 왜냐하면 위에서 정리했듯이 논블로킹방식은 정상데이터가 올 때 까지 계속 시스템콜을 하며 문맥교환을 한다.
- IO 지연(latency) 초래한다.

만약에, **개발팀장이 업무를 '동기적'으로 처리** 한다면,,?

1. 개발팀장이 사원1 에게 업무A를 지시한다.
2. 개발팀장은 사원1이 업무 A를 끝마칠때 까지 사원1 모니터 뒤에서 기다린다.. 끝날때까지!! → 동기적 작업 지시
3. 사원1이 업무 A를 끝내면 개발팀장이 확인한다.
4. 개발팀장이 사원2 에게 업무 B를 지시한다.
5. 개발팀장은 사원2가 업무 B를 끝마칠때까지 모니터 뒤에서 기다린다.. 끝날때까지 !! → 동기적 작업
6. 사원2가 업무 B를 끝내면 개발팀장이 확인

전체적인 작업의 흐름을 제어하는 개발팀장이 사원에게 업무를 지시하고, 그 사원이 해당 업무를 끝내고 보고 받을 때 까지 기다리게 됩니다.

사원2와 사원3은 업무만 지시된다면 성실하게 수행할 준비가 되어있지만, 개발팀장의 작업 흐름상 앞선 사원의 일이 끝날 때까지 작업을 진행하지 못하게 됩니다.

# 비동기 + 블로킹

![blocking_nonblocking (6)](\assets\img\blocking_nonblocking (6).png)

- IO는 논블로킹이고 알림(notify)가 블로킹인 방식이다.
- select() 시스템함수 호출이 사용자프로세스를 블로킹한다.
- 비효율적이다.

만약에, 개발팀장이 업무를 '비동기적'으로 처리하지만 사원들이 업무를 '블로킹'하게 진행한다면 아래와 같은 시나리오가 발생됩니다.

1. 개발팀장이 사원1에게 업무A를 지시하고, 사원2에게 업무B를 지시하고 싶었지만... (비동기적 작업 지시를 하고 싶었지만)
2. 사원1이 개발팀장을 붙잡는다. (블로킹 방식의 작업처리)
3. 그리고 사원1은 자신의 일이 다 끝날때 까지 개발팀장을 놓아주지 않는다.
4. 사원1의 업무가 끝나고 보고받고 나서야, 개발팀장은 사원2에게 업무B를 지시한다.
5. ...(사원2,3 생략)..

개발팀장이 '비동기적'으로 작업을 진행하고 싶다하여도, 사원들이 개발팀장을 붙잡는다면 (blocking) 개발팀장은 사원들의 업무가 끝나고 보고 될 때까지 기다리게 됩니다.

# 동기 + 블로킹

두번째 시나리오와 같게된다.

![blocking_nonblocking (7)](\assets\img\blocking_nonblocking (7).png)

- 프로그램이 블로킹을 일으키는 시스템 함수를 호출
- 한 작업당 한 번의 사용자-커널사이의 문맥교환 발생
- 정지된 프로그램은 CPU를 사용하지 않고 커널의 응답을 대기
- 프로그램 관점에서 보면 마치 처리로직이 오래걸리는 것 같지만, 사실은 커널의 일을 기다리느라 블록되어 있는 것이다. 이게 개선 포인트